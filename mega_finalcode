/* 
This is the integrated code for the Mega for our sensior design
project. The Mega is interfaced with the GSM, GPS, temperature, 
compass, Bluetooth and Uno.

Version 1.3
11/22/2015
Latest Changes: 
1. Code for almost-full successful system test on land.
   Missing the sonar module, but everything else is working. 
   It currently requires bluetooth, however.

*/
#include <SPI.h>
#include "Adafruit_BLE_UART.h"

#include <SoftwareSerial.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <Wire.h>
#include <TinyGPS++.h>
#include <math.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_HMC5883_U.h>

#define ADR_UNO 5
#define rxPin 11
#define txPin 10
Adafruit_HMC5883_Unified mag = Adafruit_HMC5883_Unified(12345);

#define ADAFRUITBLE_REQ 3
#define ADAFRUITBLE_RDY 2     // This should be an interrupt pin, on Uno thats #2 or #3
#define ADAFRUITBLE_RST 49
/*
      BTE MOSI  50
      BTE MISO  52
*/

#define STATPIN 9
//#define PWKPIN 7
#define TEMPPIN 4
#define BATTERYREADPIN 3;

String POSTPASS = "ST2015";

#define SAMPLING_NUMBER 2
#define SAMPLING_PERIOD 5  //Seconds between samples. 

OneWire oneWire(TEMPPIN);
DallasTemperature sensors(&oneWire);
DeviceAddress ourThermometer = {0x28, 0x09, 0x25, 0x50, 0x06, 0x00, 0x00, 0xAB };

//String GETURL = "http://stumpthumpers.comuv.com/tx.php";
String POSTURL = "http://stumpthumpers.comuv.com/tx.php";
String READURL = "http://stumpthumpers.comuv.com/destination.php";

//Current lat and long
//The defined values are dummy values to be used for the purpose of testing the sending of GPS coordinates.
//String GPSlat_present = "31.123456";
//String GPSlong_present = "-91.123456";
String GPSlat_target = "20.2000";
String GPSlong_target = "-90.1010";

TinyGPSPlus gps;
SoftwareSerial ss(rxPin,txPin);

long startTime;
long durationTime = 3000;
long currentTime;

long startTime_read;
long durationTime_read = 60000; //in ms

boolean flag_there = false;
boolean data_sent = false;
boolean flag_cmd = false;
boolean flag_unoPresent = false;
boolean flag_targetChange = false;

int samplesTaken = 0;

//For GPS
//gps points 
double dLat;
double dLng;
double cLat; 
double cLng;
uint32_t cCourse; 
double deltaLat = 10;
double deltaLng = 10; 

//dummy points for current 
double dummyLat = 30.1234;
double dummyLong = -70.5567;
static const uint32_t dummyCourse = 90; 

//dummy points for destination
double dummyDestLat = 31.3412;
double dummyDestLong = -91.3412;

//for servo
float angle;

int isVal = 0; 
int loc; 
String outCom; 
boolean communication; 

// for parsing incoming transmission - doesn't have to be global
int leftPoint; 
int rightPoint;
String out = "";
String lat;
String lng; 
//hack to try and make my serial input work 
//int tmpleftPoint; 
//int tmprightPoint;
//String tmpout = "";
boolean dummySet = false;
String tmplat;
String tmplng; 

//GPS Variables
#define MAX_DISTANCE 1000  //(m) Max distance to allow the device to travel
#define DISTANCE_ACCURACY 20   //(m) How far we want to be from the destination 
float distanceFrom = 0;     //(m) How far we are from the destination

//Bluetooth variables
String bteLat = "";
String bteLng = "";
//Adafruit_BLE_UART BTLEserial = Adafruit_BLE_UART(ADAFRUITBLE_REQ, ADAFRUITBLE_RDY, ADAFRUITBLE_RST);
Adafruit_BLE_UART uart = Adafruit_BLE_UART(ADAFRUITBLE_REQ, ADAFRUITBLE_RDY, ADAFRUITBLE_RST);

//Servo Variables
int SERVO_MIN = 65;    //Limits (in degrees)
int SERVO_MAX = 140;

void setup() {
  // put your setup code here, to run once:
  
  Serial.begin(115200);
  //Serial.println("Arduino serial initialized!");
  delay(10);

  Serial2.begin(9600);
  //Serial.println("GSM serial initialized!");
  delay(10);
  
  ss.begin(9600);
  //Serial.println("GPS serial intialized!");
  delay(10);
  
  sensors.begin();
  sensors.setResolution(ourThermometer, 10);
  
  Wire.begin();
  //Wire.onReceive(receiveEvent);
  //Wire.onRequest(requestEvent);
 // BTLEserial.begin();
    uart.setRXcallback(rxCallback);
  uart.setACIcallback(aciCallback);
  // uart.setDeviceName("NEWNAME"); /* 7 characters max! */
  uart.begin();
}
aci_evt_opcode_t laststatus = ACI_EVT_DISCONNECTED;
void loop() {
  //delay(500);
  //float batteryRead = analogRead(A4);
  //Serial.print("Batter: " );
  //Serial.println(batteryRead * (0.0049) * 11);
  //Set up the Temperature sensor and GSM modem.
  //bluetooth();
  uart.pollACI();
  //Setup devices
  setupTemp();
  setupModem();
  setupGPS(2, 40);
  setupCompass();
  checkSlave(ADR_UNO, false);    //Check if Uno is connected.
  
  //Execute a read to get the target location
  Serial.println("READ WEBSITE TO GET NEW TARGET COORDINATES");
  blueOut("Getting dest. data");
  sendRead();
  blueOut("Got dest. data");  
  delay(1000);
  startTime_read = millis();
  while(true)
    {
      uart.pollACI();
      //Get current location from GPS
      setPoints();
      updateDistance();
      //if ( dLat == cLat && dLng == cLng)
      if (distanceFrom <= DISTANCE_ACCURACY)
      {
        Serial.println("Arrived at Destination");
        blueOut("Arrived!");
        flag_there = 1; 
        sendToUno(ADR_UNO);
        while(flag_there == 1)
          {
           //Send Samples
           if (samplesTaken == 0)
             {
              blueOut("Sending Samples");    
              for (int k=0; k<SAMPLING_NUMBER; k++)
                {
                    Serial.println("SENDING SAMPLE " + String(k));
                    blueOut("Sending sample " + String(k+1));
                    sendPost();
                    samplesTaken++;
                      if (k < SAMPLING_NUMBER-1)
                        delay(SAMPLING_PERIOD*1000);  //Wait sampling period.
                }  
              Serial.println("SAMPLES SENT");
              blueOut("Samples sent");
              startTime_read = millis();
              }
            
            //Serial.println("READING ... ");
            //flag_targetChange is updated by sendRead if the read gps location is new
            //set up timer so read only happens every n seconds
            if (millis() > startTime_read + durationTime_read)
              {
                sendRead();
                if (flag_targetChange == 1)
                  {
                    flag_there = 0;
                  }
                startTime_read = millis();
                Serial.println("READ CMD SENT");
                blueOut("Read for new dest.");
              } 
          }
      }
      else{
        //Get our heading
        cCourse = getHeading();
      
        //Calculate the servo angle
        calculateServo();
      
        //Send data to the Uno
        flag_there = 0; 
        sendToUno(ADR_UNO);
      }
      readResponse();
      delay(500);
    }
}

/*
    START OF TRANSMISSION-SPECIFIC FUNCTIONS
*/

String issueAndSave(const char* msg) {
   String out = "";
   char in_c;
   Serial2.println(msg);
   delay(500);
   while (Serial2.available()){
    in_c = Serial2.read();
    Serial.write(in_c);
    out = out + String(in_c);
    delay(10);
  }
  return out;
}

void issueCommand(const char* msg) {
  Serial2.println(msg);
  delay(500);
  readResponse();
  delay(500);
}

void issueCommand2(const char* msg, const char* resp) {
  String checkFor = resp;
  int checkForLength = checkFor.length();
  char output[checkForLength];
  String outStr;
  int i = checkForLength - 1;
  byte in_b;
  boolean canGo = false;
  boolean sentData = false;
  flag_cmd = false;
  startTime = millis();
  while (canGo == false)
  {
  if (checkForLength <= 1)
  {
    canGo = true;
    Serial2.println(msg); 
    delay(500);
    readResponse();
    delay(500);
  }
  else
  {
    if (sentData == false)
      {
        sentData = true;
        Serial2.println(msg);
        //canGo = true;  //Don't want to just endlessly just resend the command. Give up after three attempts.
      }
    delay(500);
    while (Serial2.available()) {
       in_b = Serial2.read();
       Serial.write(in_b);
       if (in_b != 0 && in_b != '\n' && in_b != '\r' && in_b !='\n\r' && in_b != '\r\n')
       {
          if (i > 1)
          {
          for(int k=1; k < i; k++)
            {
              output[k-1] = output[k];
            }
          output[i] = in_b;
          }else
          {
            output[0] = output[1];
            output[1] = in_b;
          }
       }
       delay(10); 
    }
    String test;
    for (int k=0; k < checkForLength; k++)
      {
        test = test + String(output[k]);
      }
    //Serial.println("Output: " + test);
    if (test == checkFor)
      {
       canGo = true;
      }
 
    if (millis() > startTime + durationTime)
      {
        //Time's up
        flag_cmd = true;
        canGo = true;
      }
 }
 
 }
}

void readResponse() {
  uart.pollACI();
  while (Serial2.available()){
    if (Serial2.available() >= 64)
      {
        Serial.println("Overflooooow");
      }
    Serial.write(Serial2.read());
    delay(10);
  }
}


/*
DEPRECATED

Sends an HTTP GET request to the website. The url for the form is defined by GETURL
The final url to be used will be:
GETURL?tmp=TEMPVALUE&lat=LATVALUE&long=LONGVALUE
The TEMPVALUE is obtained within the function. The current GPS Coordinates are stored in 
the global variables, GPSlat_present and GPSlong_present

result is the url to be supplied to the Quectel M95 after sending the AT+QHTTPURL=n,m command where n is the size (in bytes) of result
resultInfop is the pointer that points to the string/char array of the AT+QHTTPURL command and resultp is the pointer for result.

void sendGet() {
  //Create the URL to send the HTTP GET request to.
  String result = GETURL + "?tmp=" + String(getTemperature(ourThermometer)) + "&lat=" + GPSlat_present + "&long=" + GPSlong_present + "&pw=" + POSTPASS;
  //Prepare the AT command that declares the amount of bytes of the url to send the request to and the max time to send (in seconds)
  String resultInfo = "AT+QHTTPURL=" + String(result.length()) + ",30";
  //Convert the two above strings to const char *, which is what the issueCommand function requires
  const char * resultp = result.c_str();
  const char * resultInfop = resultInfo.c_str();
  
  //Issue the AT commands
  issueCommand("AT+QIFGCNT=0");
  issueCommand("AT+QIDNSIP=1");
  issueCommand("AT+QICSGP=1,\"truphone.com\",\"\",\"\""); //Set the APN
  
  issueCommand(resultInfop);
  issueCommand(resultp);
  issueCommand2("AT+QHTTPGET=60","OK");
  //delay(5000);
  issueCommand("AT+QHTTPREAD=30");  //Send the read request. Not currently in use.  
  delay(2000);
  issueCommand("AT+QIDEACT");
  
}
*/
/*
Sends an HTTP POST request to the website. The url for the form is defined by POSTURL. (Which is currently the same as GETURL
The TEMPVALUE is obtained within the function (like with sendGet(), using getTemperature)
Lat and Long are saved within the global variables.

result is the url to be supplied to AT+QHTTPURL=n,m where n is the size (in bytes) of result

*/
void sendPost() {
  uart.pollACI();
  String result = POSTURL;  
  String resultInfo = "AT+QHTTPURL=" + String(result.length()) + ",30";
   String dataToSend = "msg=" + String(getTemperature(ourThermometer));
  dataToSend = dataToSend + "||" + String(cLat);
  dataToSend = dataToSend + "||" + String(cLng);
  dataToSend = dataToSend + "||" + GPSlat_target;
  dataToSend = dataToSend + "||" + GPSlong_target;
  dataToSend = dataToSend + "||" + POSTPASS;
  String postInfo = "AT+QHTTPPOST=" + String(dataToSend.length()) + ",50,10";
  
  //Convert the above strings to const char *, which is what the issueCommand function requires
  const char * resultp = result.c_str();
  const char * resultInfop = resultInfo.c_str();
  const char * dataToSendp = dataToSend.c_str();
  const char * postInfop = postInfo.c_str();

  //Issue the AT commands  
  issueCommand("AT+QIFGCNT=0");
  issueCommand("AT+QIDNSIP=1");
  issueCommand("AT+QICSGP=1,\"truphone.com\",\"\",\"\""); //Set the APN
  issueCommand(resultInfop);
  issueCommand(resultp);
  issueCommand2(postInfop,"CONNECT");
  issueCommand2(dataToSendp,"OK");
  issueCommand("AT+QHTTPREAD=30"); //Send the read request. Not currently in use. 
  issueCommand("AT+QIDEACT");
  
}

void sendRead() {
  uart.pollACI();
  //Create the URL to send the HTTP GET request to.
  String result = READURL;
  String result2;
  //Prepare the AT command that declares the amount of bytes of the url to send the request to and the max time to send (in seconds)
  String resultInfo = "AT+QHTTPURL=" + String(result.length()) + ",30";
  //Convert the two above strings to const char *, which is what the issueCommand function requires
  const char * resultp = result.c_str();
  const char * resultInfop = resultInfo.c_str();
  
  String output;
  //char outChar[ ];
  boolean gettingLL = false;
  boolean writingLat = false;
  int leftPoint = 0;
  int rightPoint = 0;
  
  //Issue the AT commands
  issueCommand("AT+QIFGCNT=0");
  issueCommand("AT+QIDNSIP=1");
  issueCommand("AT+QICSGP=1,\"truphone.com\",\"\",\"\""); //Set the APN
  
  issueCommand(resultInfop);
  issueCommand(resultp);
  issueCommand2("AT+QHTTPGET=60","OK");
  output = issueAndSave("AT+QHTTPREAD=30");  //Send the read request.
  leftPoint = output.indexOf('[');
  rightPoint = output.indexOf(']', leftPoint + 1);
  if (leftPoint != rightPoint && rightPoint > leftPoint)
    {
    output = output.substring(leftPoint+1,rightPoint);
    leftPoint = output.indexOf(',');    // Is now a middle point
    result = output.substring(0,leftPoint);
    result2 = output.substring(leftPoint+1, output.length());
    Serial.println(result);
    if (result.equals(GPSlat_target) && result2.equals(GPSlong_target))
      {
        //No change to the target location
        flag_targetChange = false;
      }
    else 
      {
        //There's been a change to the target location
        GPSlat_target = result;
        GPSlong_target= result2;
        
        dLat = GPSlat_target.toFloat();
        dLng = GPSlong_target.toFloat();
        flag_targetChange = true;
        samplesTaken = 0; // Reset the samples taken so we can take more at the new location.
        Serial.println("TARGET LOCATION CHANGED: samplesTaken = 0");
      }
    }
  //delay(5000);
  issueCommand2("AT+QIDEACT","DEACT OK");
   
}

void setupModem() {
 issueCommand2("AT","OK");
 while (flag_cmd)
  {
    //Modem not communicating properly, try again
    issueCommand2("AT","OK");
    blueOut("Check Modem wiring.");
    delay(500);
  }
  Serial.println("Modem and Mega communication established.");
  blueOut("Modem online");
}

/*
    END OF TRANSMISSION-SPECIFIC FUNCTIONS
*/

/*
    START OF TEMPERATURE-SPECIFIC FUNCTIONS
*/

float getTemperature(DeviceAddress deviceAddress)
{
  
  float tempC = sensors.getTempC(deviceAddress);
  delay(100);
  float tempC2 = sensors.getTempC(deviceAddress);
  if (tempC2 != tempC)
    {
      delay(300);
      tempC = sensors.getTempC(deviceAddress);
    }
  //if (tempC == -127.00){
  //Serial.print("Error getting Temperature.");
  //tempC = -999;
  //}
  return tempC;
}
 
void setupTemp() {
  float tempC = getTemperature(ourThermometer);
  delay(500);
  float tempC2 = getTemperature(ourThermometer);
  //85 degrees C is the value after booting up. Can also occur
  //if there's a power issue (i.e., not enough to temp)
  while (tempC2 != tempC || tempC2 == 85 || tempC2 == -127)
   {
     if (tempC2 == 85 || -127)
       {
       Serial.println(String(tempC2) + ". Possible power issue.");
       blueOut("Check temp wiring.");
       }
        // report parasite power requirements
        Serial.print("Parasite power is: "); 
        if (sensors.isParasitePowerMode()) Serial.println("ON");
        else Serial.println("OFF");
        
        Serial.print(sensors.getResolution(ourThermometer), DEC); 
        
        Serial.print("Requesting temperatures...");
        sensors.requestTemperatures(); // Send the command to get temperatures
        Serial.println("DONE");
        
           tempC2 = getTemperature(ourThermometer);
           delay(500);
   } 
   Serial.println("Temperature sensor is online with temp " + String(tempC));
   Serial.println();
   blueOut("Temperature Working.");
}

/*
    END OF TEMPERATURE-SPECIFIC FUNCTIONS
*/

/*
    START OF I2C-SPECIFIC FUNCTIONS
*/
void checkSlave(int a, boolean b) {
  boolean slaveUp = false;
  boolean check = b;
  while (slaveUp == false)
  {
  Wire.beginTransmission(a);
  if (Wire.endTransmission() == 0)
    {
      if (check == true)
        {
         if (flag_unoPresent == false)
          {
            flag_unoPresent = true;
            sendToUno(ADR_UNO);
            Serial.println("Connection restored. Resending data ... ");
          }
        }
      else
        {
        flag_unoPresent = true;
        }
      slaveUp = true;
    }else
    {
      flag_unoPresent = false;
      Serial.println("Slave not found ... Trying again");
      blueOut("Uno not found ...");
      delay(2000);
    }
  delay(500);
  }
}

void sendToUno(int a) {
 String angle_out = String(angle);
 String fthere_out = String(flag_there);
 
 const char * outp = angle_out.c_str();
 const char * ftherep = fthere_out.c_str();
 
 Wire.beginTransmission(a);
 Wire.write("<");
 Wire.write(outp);
 Wire.write(",");
 Wire.write(ftherep);
 Wire.write(">");
 Wire.endTransmission(); 
}

void requestToUno(int a, int b) {
   /*
   Currently Unused -- no need to request any information from the Uno
  boolean printCheck = false;
  String output, output_piece;
  int flag1, flag2, flag3, flag4, flag5;
  Wire.requestFrom(a,b);
  while (Wire.available() > 1) {
    char c = Wire.read();
      if (c != '\n' && c != '\r' && c != '\n\r' && c != '\r\n' && c != 'Ã¿' && c != 0 && c != ' ')
        {
        output = output + String(c);
        printCheck = true;
        Serial.print(c);
        }
  }
  if (printCheck == true)
    {
      Serial.println();
      //Parse Info from Uno
        //Get the Flag Data
        flag1 = (output.substring(0,1)).toInt();
        flag2 = (output.substring(1,2)).toInt();
        flag3 = (output.substring(2,3)).toInt();
        flag4 = (output.substring(3,4)).toInt();
        flag_there = (output.substring(4,5)).toInt();
        GPSlat_present = output.substring(output.indexOf(',')+1,output.lastIndexOf(','));
        GPSlong_present = output.substring(output.lastIndexOf(',')+1, output.length());
        //output_piece = output.substring(0,output.indexOf(','));
        Serial.println("Flag Received: " + String(flag1) + ", " + String(flag2) + ", " + String(flag3) + ", " + String(flag4) + ", " + String(flag_there));
        Serial.println("Lat Present: " + GPSlat_present);
        Serial.println("Long present: " + GPSlong_present);
    }
    */
}

/*
    END OF I2C-SPECIFIC FUNCTIONS
*/

/*
    START OF GPS-SPECIFIC FUNCTIONS
*/

void setDummys(){
  String tmpout = "";
  //String tmplat = "";
  //String tmplng = "";
  int tmpLeftPoint, tmpRightPoint;
  char c;
  while (tmplat.equals(""))
  {
  while (Serial.available() > 0) 
    {  
    c = Serial.read(); 
    //Serial.write(c); 
    if (c != '\n' && c != '\r' && c != '\n\r' && c != '\r\n' && c != 0)
      {
        tmpout = tmpout + String(c);
        //Serial.write(c);
      }
     }
   
   if (!tmpout.equals(""))
       {
       tmpLeftPoint = tmpout.indexOf('<'); 
       tmpRightPoint = tmpout.indexOf('>');
       if (tmpRightPoint > tmpLeftPoint)
         {
         tmpout = tmpout.substring(tmpLeftPoint+1,tmpRightPoint); 
         //Serial.println("Should have no <>'s: " + tmpout);
         tmpLeftPoint = tmpout.indexOf(',');
           if (tmpLeftPoint > 0)
             {
             tmplat = tmpout.substring(0,tmpLeftPoint);
             tmplng = tmpout.substring(tmpLeftPoint+1, tmpout.length());
             //Serial.println("Lat: " + tmplat);
             //Serial.println("Long: " + tmplng);
             dummyLat = tmplat.toFloat();
             dummyLong = tmplng.toFloat();
                 
             tmpout = "";
             dummySet = true;
             }
         }
       }
  }

}
void setPoints(){
  //// Set current Lat and Lng and print 
  if(gps.location.isValid()){
    cLat = gps.location.lat();
    cLng = gps.location.lng();
    Serial.println("Receiving Vaild GPS Coordinates..."); 
    isVal = 1; 
  }
  else{
  Serial.println("Not Receiving vaild GPS Coordinates. Enter Dummy Variables via Bluetooth:");
   /*
   Code to use when setting current coordinates via serial and not bluetooth
   dummySet = false;
   tmplat = "";
   tmplng = "";
   while(dummySet == false)
      {
       setDummys(); 
      }
   cLat = tmplat.toFloat();
   cLng = tmplng.toFloat();
   Serial.println(cLat,4);
   Serial.println(cLng,4);  
   isVal = 0; 
   */
   bteLat = "";
   blueOut("Enter cGPS");
   while(bteLat.equals(""))
      {
        uart.pollACI();
      }
    //Serial.println("String to format: " + String(bteLat));
    formatBteResponse(bteLat);
    Serial.println("Lat to use: " + String(cLat,6) + "\nLng to us: " + String(cLng,6));
    delay(100);
    //Serial.println("Lat: " + String(gps.location.lat(),6));
    bteLat = "";
    bteLng = "";
  }
  //// Set current Heading and print 
  /*
  if(gps.course.isValid()){
    Serial.println("Receiving Vaild GPS Heading..."); 
    cCourse = gps.course.deg();
  }
  else{
   // Serial.println("Not receiving vaild GPS Heading..Using dummy Heading");
    cCourse = dummyCourse; 
  }*/
 // Set current Heading using Compass and print
 cCourse = getHeading();
 Serial.print("Heading: ");
 Serial.println(cCourse);

 // Set destination points
  /* 
  No longer receiving dest coordinates via I2C. Deprecated.
  if(communication == 1){
   Serial.println("Receiving Valid destination Coordinates");
   const char * tmpLat = lat.c_str();
   const char * tmpLng = lng.c_str(); 
    dLat = lat.toFloat(); 
    dLng = lng.toFloat(); 
 
  }
  else{
   Serial.println("Not Receiving valid destination Coordinates");
   dLat = dummyDestLat;
   dLat = dummyDestLong; 
  }*/
deltaLat=dLat-cLat;
deltaLng=dLng-cLng; 
}

void updateDistance() {
 distanceFrom = gps.distanceBetween(cLat, cLng, dLat, dLng);  
}

void calculateServo(){
 //initial caclculations
  
 double rad=3.14/180;
 int theta=round(atan(deltaLng/deltaLat)/rad);

 //figure out if theta needs to be negative or positive
 if(cLat>dLat)
 {
 theta=theta-180;
 } 
 theta=theta-cCourse;
 theta=(theta+360)%360; 
 if(theta>180){
 theta=theta-360;
 } 
 else if(theta < -180){
 theta=360+theta; 
 } 
 if(theta >90){
 angle=180;
 }
 else if(theta < -90){
 angle=0;
 }
 else{
 angle=90+theta;
 }
if (angle > SERVO_MAX)
  angle = SERVO_MAX;
if (angle < SERVO_MIN)
  angle = SERVO_MIN;
Serial.println("Angle is " + String(angle));
Serial.println("cLat is " + String(cLat));
Serial.println("cLng is " + String(cLng));
Serial.println("Theta is " + String(theta));
Serial.println("cLat: " + String(cLat,6) + ", cLng: " + String(cLng,6));
Serial.println("dLat: " + String(dLat,6) + ", dLng: " + String(dLng,6));
Serial.println("Distance Left: " + String(distanceFrom) + " m");
}

void setupGPS(long t, int tInt)  {
  Serial.println("Setup GPS");
  long timerStart = millis(); //ms
  long timerDelay = 1L;  //Minutes to give GPS to find satellites
  timerDelay = timerDelay * t * 1000 * 60;  //ms
  int printInterval = tInt;
  int i = 0;
  long currentTime;
  long remainingTime;
  
  while (!gps.location.isValid())
    {
      uart.pollACI();
      //Get new lat and long value to update isValid;
      printInt(gps.satellites.value(), gps.satellites.isValid(), 5);
      printInt(gps.hdop.value(), gps.hdop.isValid(), 5);
      printFloat(gps.location.lat(), gps.location.isValid(), 11, 6);
      printFloat(gps.location.lng(), gps.location.isValid(), 12, 6);
      printInt(gps.location.age(), gps.location.isValid(), 5);
      printDateTime(gps.date, gps.time);
      printFloat(gps.altitude.meters(), gps.altitude.isValid(), 7, 2);
      printFloat(gps.course.deg(), gps.course.isValid(), 7, 2);
      printFloat(gps.speed.kmph(), gps.speed.isValid(), 6, 2);
      printStr(gps.course.isValid() ? TinyGPSPlus::cardinal(gps.course.value()) : "*** ", 6);
      Serial.println();
      
      //Check connection issue
      if (millis() > 5000 && gps.charsProcessed() < 10)
        {
          Serial.println(F("No GPS data received: check wiring"));
          blueOut("Check GPS wiring.");
        }
      //Check if we've waited the desired amount of minutes before proceeding.
      if (millis() > (timerStart + timerDelay))
        {
          //Waited timerDelay minutes, time to quit trying.
          Serial.println("Waited " + String(timerDelay/(60L*1000L)) + " minutes. Switching to Bluetooth/Test Data from Serial.");
          blueOut("Waiting timed out.");
          break;
        }
        
      //Check if it's time to post another message to say we aren't receiving anything.
      if (millis() >= (timerStart+i*(timerDelay/printInterval)))
        {
          remainingTime = (timerStart + timerDelay) - (timerStart+i*(timerDelay/printInterval));
          i++;
          Serial.print("GPS still not receiving coordinates. "); 
          Serial.println(String(remainingTime /1000) + " seconds remaining. " + String(remainingTime/(1000L*60L)) + " minutes remaining.");
          blueOut("GPS Not Rx " + String(remainingTime /1000) + "s left");
        }
    }
  if (gps.location.isValid())
    {
    Serial.println("GPS is online. Lat: " + String(gps.location.lat(),6) + ", Long: " + String(gps.location.lng(),6));
    blueOut("GPS online");
    }
}

// This custom version of delay() ensures that the gps object
// is being "fed".
static void smartDelay(unsigned long ms)
{
  unsigned long start = millis();
  do 
  {
    while (ss.available())
      gps.encode(ss.read());
  } while (millis() - start < ms);
}

static void printFloat(float val, bool valid, int len, int prec)
{
  if (!valid)
  {
    while (len-- > 1)
      Serial.print('*');
    Serial.print(' ');
  }
  else
  {
    Serial.print(val, prec);
    int vi = abs((int)val);
    int flen = prec + (val < 0.0 ? 2 : 1); // . and -
    flen += vi >= 1000 ? 4 : vi >= 100 ? 3 : vi >= 10 ? 2 : 1;
    for (int i=flen; i<len; ++i)
      Serial.print(' ');
  }
  smartDelay(0);
}

static void printInt(unsigned long val, bool valid, int len)
{
  char sz[32] = "*****************";
  if (valid)
    sprintf(sz, "%ld", val);
  sz[len] = 0;
  for (int i=strlen(sz); i<len; ++i)
    sz[i] = ' ';
  if (len > 0) 
    sz[len-1] = ' ';
  Serial.print(sz);
  smartDelay(0);
}

static void printDateTime(TinyGPSDate &d, TinyGPSTime &t)
{
  if (!d.isValid())
  {
    Serial.print(F("********** "));
  }
  else
  {
    char sz[32];
    sprintf(sz, "%02d/%02d/%02d ", d.month(), d.day(), d.year());
    Serial.print(sz);
  }
  
  if (!t.isValid())
  {
    Serial.print(F("******** "));
  }
  else
  {
    char sz[32];
    sprintf(sz, "%02d:%02d:%02d ", t.hour(), t.minute(), t.second());
    Serial.print(sz);
  }

  printInt(d.age(), d.isValid(), 5);
  smartDelay(0);
}

static void printStr(const char *str, int len)
{
  int slen = strlen(str);
  for (int i=0; i<len; ++i)
    Serial.print(i<slen ? str[i] : ' ');
  smartDelay(0);
}

/*
    END OF GPS-SPECIFIC FUNCTIONS
*/

/*
    START OF COMPASS-SPECIFIC FUNCTIONS
*/

float getHeading() {
  sensors_event_t event;
  mag.getEvent(&event);
  float heading = atan2(event.magnetic.y, event.magnetic.x);
  // Once you have your heading, you must then add your 'Declination Angle', which is the 'Error' of the magnetic field in your location.
  // Find yours here: http://www.magnetic-declination.com/
  // Mine is: -13* 2' W, which is ~13 Degrees, or (which we need) 0.22 radians
  // If you cannot find your Declination, comment out these two lines, your compass will be slightly off.
  
  float declinationAngle = 0;
  heading += declinationAngle;
  
  // Correct for when signs are reversed.
  if(heading < 0)
    heading += 2*PI;
    
  // Check for wrap due to addition of declination.
  if(heading > 2*PI)
    heading -= 2*PI;
   
  // Convert radians to degrees for readability.
  float headingDegrees = heading * 180/M_PI;
  return headingDegrees;
}

void setupCompass() {
   Serial.print("Heading: ");
   Serial.println(getHeading());
   delay(500); 
}

/*
    END OF COMPASS-SPECIFIC FUNCTIONS
*/
//void bluetooth(){
//    // Tell the nRF8001 to do whatever it should be working on.
//    Serial.print("In bluetooth Module");
//  BTLEserial.pollACI();
//
//  // Ask what is our current status
//  aci_evt_opcode_t status = BTLEserial.getState();
//  // If the status changed....
//  if (status != laststatus) {
//    // print it out!
//    if (status == ACI_EVT_DEVICE_STARTED) {
//        Serial.println(F("* Advertising started"));
//    }
//    if (status == ACI_EVT_CONNECTED) {
//        Serial.println(F("* Connected!"));
//    }
//    if (status == ACI_EVT_DISCONNECTED) {
//        Serial.println(F("* Disconnected or advertising timed out"));
//    }
//    // OK set the last status change to this one
//    laststatus = status;
//  }
//
//  if (status == ACI_EVT_CONNECTED) {
//    // Lets see if there's any data for us!
//    if (BTLEserial.available()) {
//      Serial.print("* "); Serial.print(BTLEserial.available()); Serial.println(F(" bytes available from BTLE"));
//    }
//    // OK while we still have something to read, get a character and print it out
//    while (BTLEserial.available()) {
//      char c = BTLEserial.read();
//      Serial.print(c);
//    }
//
//    // Next up, see if we have any data to get from the Serial console
//
//    if (Serial.available()) {
//      // Read a line from Serial
//      Serial.setTimeout(100); // 100 millisecond timeout
//      String s = Serial.readString();
//
//      // We need to convert the line to bytes, no more than 20 at this time
//      uint8_t sendbuffer[20];
//      s.getBytes(sendbuffer, 20);
//      char sendbuffersize = min(20, s.length());
//
//      Serial.print(F("\n* Sending -> \"")); Serial.print((char *)sendbuffer); Serial.println("\"");
//
//      // write the data
//      BTLEserial.write(sendbuffer, sendbuffersize);
//    }
//  }
//   
//}
void aciCallback(aci_evt_opcode_t event)
{
  switch(event)
  {
    case ACI_EVT_DEVICE_STARTED:
      Serial.println(F("Advertising started"));
      break;
    case ACI_EVT_CONNECTED:
      Serial.println(F("Connected!"));
      break;
    case ACI_EVT_DISCONNECTED:
      Serial.println(F("Disconnected or advertising timed out"));
      break;
    default:
      break;
  }
}

/**************************************************************************/
/*!
    This function is called whenever data arrives on the RX channel
*/
/**************************************************************************/
void rxCallback(uint8_t *buffer, uint8_t len)
{
  //Serial.print(F("Received "));
  //Serial.print(len);
  //Serial.print(F(" bytes: "));
  for(int i=0; i<len; i++)
    {
     bteLat += String((char)buffer[i]);
     //Serial.print((char)buffer[i]); 
    }

  //Serial.print(F(" ["));

  for(int i=0; i<len; i++)
  {
    //Serial.print(" 0x"); Serial.print((char)buffer[i], HEX); 
  }
  //Serial.println(F(" ]"));

  /* Echo the same data back! */
  uart.write(buffer, len);
}

//Interpret data from bluetooth
//Should receive lat, lng in the form <lat,lng>
void formatBteResponse(String s) {
   String out = s;
   //Serial.println("Received: " + s);
   int leftPoint = 0;
   int rightPoint = 0;
   leftPoint = s.indexOf('<');
   rightPoint = s.indexOf('>');
   if (rightPoint > leftPoint)
     {
     s = s.substring(leftPoint+1,rightPoint);
     //Serial.println("Arrows gone: " + s);
     rightPoint = s.indexOf(',');
     if (rightPoint > leftPoint)
       {
         bteLat = s.substring(0,rightPoint);
         bteLng = s.substring(rightPoint+1,s.length());
         cLat = bteLat.toFloat();
         cLng = bteLng.toFloat();
       }
      else
       {
         bteLat = "";
         bteLng = "";
       }
     }
   else
     {
       bteLat = "";
       bteLng = "";
     } 
}

void blueOut(String s) {
  uart.pollACI();
  uart.print(s);   
}
